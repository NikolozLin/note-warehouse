# 第二章

## 变量和基本数据类型

### 基本数据类型

|类型|含义|最小尺寸|
|-|-|-|
|`bool`|布尔类型|未定义|
|`char`|字符|8位|
|`wchar_t`|宽字符|16位|
|`char16_t`|Unicode字符|16位|
|`char32_t`|Unicode字符|32位|
|`short`|短整型|16位|
|`int`|整型|16位|
|`long`|长整型|32位|
|`long long`|长整型|64位|
|`float`|单精度浮点数|6位有效小数|
|`double`|双精度浮点数|10位有效小数|
|`long double`|扩展精度浮点数|10位有效小数|

### 如何选择类型

1. 明确数值不可能为负数， 选用`无符号类型`
2. 使用`int`执行整数运算，范围超过`int`表示范围使用`long long`类型， 因为short显示太小一般long与int范围查不多
3. 算术表达式不要使用`char`、`bool`类型
4. 浮点计算需要难过`double`类型，float精度往往不够

### 类型转换

- 无符号类型赋值了一个负数

    ```c++
    // val实际值为 4294967295=2^32-1
    unsigned int val = -1;
    ```

    计算机内存存储的二进制是按补码存储的，正数补码与原码相同，负数补码是原码取反+1.  

    -1的二进制补码 1111 1111 1111 1111 1111 1111 1111 1111，正数补码与原码相同即址为2^32-1。
    所以负数赋值给`无符号类型的值`=`无符号类型最大值`-`负数`+`1`  ,这个1是负数原码转补码时候加的1.
- 对变量赋值值，如果超出 类型范围，那这个变量将是为定义

### 字面值常量

如`42`这般的值称之为`字面值常量`，可以看到值就推断出数据类型。  

- 整型、浮点型 字面值
  - 整型
    ||||
    |-|-|-
    |十进制| 20 |（带符号） （类型可能为int、long、long long）
    |八进制|020 |（可能带或不带符号）（类型为...）
    |十六进制|0x14 |（可能带或不带符号）（类型为...）
  - 浮点型 （默认类型为double，可用其他后缀表示其他类型）
        浮点型表示为一个小数或科学计数法， 指数部分用e或E表示

- 字符、字符串 字面值
    单引号包裹的一个字符是`char`型的字面值 ，双引号括起来的零个或多个字符为字符串型的字面值。
  - 'a' :`char`型的字面值
  - “aaa” : 字符串字面值类型是`字符常量`构成的`array`,编译器会在字符串结尾添加空字符`\0`. 字符串实际长度会比内容多。
  - "a" 比'a' 多了一个空白字符 '\0'
  - 如果两个字符串字面量位置紧邻，且中间由空格、缩进、换行符分隔。其实上他们是一个整体

- 转义序列 （无法答应的字符 或 c++语言中有特色含义的字符 都需要转义才可使用）
    ||||
    |-|-|-|
    |`\n`换行符|`\t`横向制表符|`\a`报警符|
    |`\v`纵向制表符|`\b`退格符|`\"`双引号|
    |`\\`反斜杠|`\？`问符|`\'`单引号|
    |`\r`回车|`\f`进纸符||

- 指定字面值类型
    可以改变整型、浮点型、字符型字面值得默认类型
  - 字符和字符串字面值  
    |前缀|含义|
    |-|-|
    |`u`|Unicode16字符|
    |`U`|Unicode32字符|
    |`L`|宽字符|
    |`u8`|Utf-8(仅用于字符串字面量)|

  - 整型字面值  
    |前缀|含义|
    |-|-|
    |`u OR U`|unsigned|
    |`l OR L`|long|
    |`ll OR LL`|long long|

  - 浮点型字面值  
    |前缀|含义|
    |-|-|
    |`f OR F`|float|
    |`l OR L`|long double|

- 布尔字面值
    `true`和`false`
- 指针字面值
  `nullprt`

---

## 变量

变量提供一个具名、可供程序操作的存储空间。C++中的`变量` `对象`一般可以互换使用。

### 变量定义

- **定义形式** : `类型说明符` `变量名` `=` `初始化的值或表达式`
    变量名以逗号`,`分隔，分号`;`结束
- **初始化** ：创建对象（变量）获得一个特定的值
  - 初始化的值可以是复杂表达式。
  - 多个变量同时定义时，前一个变量定义完后可以立马使用。
  >c++中初始化和赋值是两个完全不同的操作，初始化是创建变量时赋予一个初始值，赋值是清空变量的当前值，用一个新的值来代替。
- **列表初始化**

  ```c++
  //使用花括号初始化变量
  int units_sold={0};
  ```

  - 使用列表初始化，初始化一个内置类型的变量（非内置的类有自己的初始化逻辑）时，如果存在丢失信息的风险，编译器会报错。
- **默认初始化**
  - 定义变量但没有指定初始值，变量会给默认初始化。默认值由变量类型、变量的位置决定。
  - 定义于函数体外的`内置类型`的变量默认初始化为`0`。
  - 定义于函数体内的`内置类型`的变量不会被初始化，值为未定义。当访问这个值会导致程序出错。
- **变量声明和定义的关系**
  - 定义= 声明+初始化值
  - c++支持分离式编译机制，所以声明和定义是分开的。
  - 相同点：二者都会规定 `变量类型`和`名字`。
  - 不同点：
    - 但声明需要在变量名前添加`extern`关键字并且不能显示初始化变量。
    - 定义只能一次，声明可以多次。
  - 声明：使名字为程序所知，使用别处定义的名字需先声明那个名字。
  - 定义：创建与名字关联的实体。 会申请存储空间，可能还会赋一个初始值。

  ```c++
  //函数体外 使用了 extren 并给了一初始值
  extern double pi= 3.14159; //定义
   //函数体内 使用了 extren 并给了一初始值，编译器会报错
  extern double pi= 3.14159; //报错
  
  ```

- **标识符**
  标识符由字母、数字、下划线组成，字母、下划线开头，大小写敏感。
- **名字的作用域**
  - 程序中使用到的名字都会指向一个特定的实体：变量、函数、类型等。如果同个名字出现在程序不同位置，他们指向的实体可能不同。
  - C++中的作用域一般用花括号`{}`分隔。

---

## 复合类型

  c++中有好几种复合类型，这里只说 `引用（一般指左值引用）`和`指针`。

### 1. 引用

- 引用为一个对象启用另外一个名字，在声明名字的前面添加`&`符号，
- 初始化时程序会把引用和初始值绑定在一起 所以初始值不能为空。
- 定义引用时的类型必须与原始值类型严格匹配。

  ```c++
  int value=10;
  int &name=value;
  ```

### 2. 指针  

指针在定义时候需要在变量前添加`*`，指针本身是一个对象，指针无需在定义时赋值。如果没有呗初始化将拥有一个不却确定的值（容易出错，最好全初始化，却确定值初始化为空指针）。

- **获取对象的地址**
  - 获取地址需使用`取地址符` `&`
  - 指针与被指向的对象类型必须相同（特例：）
- **指针值**
  1. 指向一个对象
  2. 指向相邻对象所占空间的下一个位置
  3. 空指针
  4. 无效指针，即上述之外的其他值。 （拷贝或访问无效指针的 值 都会引发错误）
- **利用指针访问对象（如果不知指向对象则不可用）**

  ```c++
  int ival=42;
  int *p=&ival;
  *p=2;
  
  ```

  - 如果指针指向一个对象，允许用`解引用符号 *`来访问所指向对象。
  - 如上，对`*p`赋予一个新值，其实是对`ival`变量进行赋值
- **空指针**
  不指向任何对象的指针。

  ```c++
   int *p1 = nullptr;  //等价于 int *p1 = 0;
   int *p2 = 0;        //直接将p2初始化为字面量0
   //需要先引入 #include cstdlib 
   int *p3 = NULL;     //等价于int *p3 = 0;
  ```

  - 推荐使用`nullptr`来初始化执政，`nullptr`是特殊类型值，可被转换成任意其他的指针类型。
  - 字面值`0` 可以生成空指针。
  - `NULL`是预处理变量，值为`0`。变量存在`cstdlib`头文件中
- **赋值和指针**
- **其他操作**
- **`void *`指针**
  特殊类型的指针，可以存放任意类型的指针(类型不同也可)

### 3. 理解复合类型的声明

  复合类型声明= 基本数据类型 + 类型修饰符(*、&) +变量名

- 类型修饰符是用来修饰变量名的，所以连续声明多个指针必须每个指针都带有修饰符`*`
- **指向指针的指针**
  类型修饰符个数没有使用的限制，多个修饰符可以根据逻辑意义解释即可。
  使用`解引符号*`时，声明用了多少个类型修饰符，获取值就要用多少个解引符号。

  ```c++
  int *p=nullptr; //指针
  int **p1=0;//指向指针的指针
  int ***p2=0; //指向一个指针（该指针指向另外的一个指针）
  ```

- **指向指针的应用**

  ```c++
  int a=1024;
  int *p=&a;
  int *&r=p; //指向指针的引用
  ```

> 遇到复杂的引用或指针声明，可以从右向左阅读

## cost限定符

对变量进行限定，限制对变量的修改。

- 一旦初始化就无法修改，所以**声明变量**的时候就需要进行**初始化**。

-
