---
date created: 2022-03-24 11:01
date updated: 2022-03-24 17:29
---

# ES6 module 和CommonJS 区别

主要区别

1. cjs 模块输出值的拷贝(非基本类型也是值拷贝，不过值就是内存地址)，esm模块输出的是值的引用。
2. cjs 模块运行时加载，esm模块是编译时加载。
3. cjs模块 require 是同步加载模块，esm模块 import 是异步加载（有个独立的模块依赖的解析阶段）。

---

输出区别：

- CommonJS
  - 值拷贝，加载后模块内部变化_不影响_已输出的值（如果是基本类型无法影响，如果是对象的内存地址，内部改变了外部同样改变）。
- ES6 module
  - 值的引用，加载后模块内部变化_影响_已输出的值 以为esm会进行静态分析。加载import 命令只生成一个 _只读引用_ 。脚本真正运行后，根据引用到模块里面去取值。如果模块内的原始值变了，外部的值也会改变。
    - 只读引用类似于Unix系统的符号连接，重新赋值会报错。

## 循环加载
执行区别：
js代码执行前，会进行编译。其中会对变量进行变量提升。

- CommonJS
  第一次 require 执行模块后，内存中会生成一块像下面一样的空间。

  ```
  {
    id: '...', // 模块名
    exports: { ... }, // 模块输出值各种接口
    loaded: true, // 模块是否执行完毕
    ...
  }
  ```

  上面是exports 模块输出的值。 当你用到这个模块就会到exports属性上取值。_如果有多次require 该模块也不会执行_，而在内存中的对象直接取值。 即，require后 模块内部的变化对上面输出的东西没有影响（上面的值如果是指向模块内部的内存地址 除外）。

### CommonJS 循环引用加载过程
- CommonJS 模块的重要特性是加载时执行，即脚本代码在`require`的时候，就会全部执行。一旦出现某个模块被"循环加载"，就只输出已经执行的部分，还未执行的部分不会输出。


- ES6 module

  当代码编译时，发现有import语句，此时会先加载（执行）import 进来的js。然后在继续执行后续代码。

  ES6 模块输出的值引用，意味着如果输出的是一个object 那么输出的值引用就是内存地址。当这个object的A属性值给修改时，在其他地方获取这个object的A属性值会得到最新的值。


