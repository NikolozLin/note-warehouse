---
date created: 2022-04-08 16:24
date updated: 2022-04-08 22:38
---

## 执行前的准备

![[v8-initial structure.png]]
如图，V8引擎的运行需要依赖浏览器活着node提供的基础环境（堆栈、事件循环、消息队列、WebAPI、Window DOM）。
运行环境初始化：
当浏览器中当一个渲染进程打开后，渲染进程会初始化V8引擎，同时初始化 堆栈、上下文等。

###  第一步、初始化堆栈

- 堆空间：存放除了基础类型外的对象类型，如 函数、数组、浏览器的window对象、document对象等
- 栈空间（空间连续）：函数调用过程中，相关上下文存放在栈上，如原生类型、引用对象的地址、函数执行状态、this等值，当函数执行完会，相关上下文会被销毁（涉及垃圾回收）

### 第二步、初始化全局执行上下文、全局作用域

### 第三步、构造事件循环系统

V8需要一个_主线程_来执行JS和执行垃圾回收工作。但是V8寄生在宿主环境中，所以需要使用宿主提供的_主线程_ 。

当线程执行完一段代码后会自动推出，执行过程中栈中的数据也随之销毁。下次启动新线程，重新初始化栈数据。会严重影响执行性能。

所以为了线程不退出会使用下面类似的循环，循环中监听一个事件，需要执行另外的代码就激活循环执行（eventloop、任务队列）。

```
while(1){
	Task task =GetNewTask();
	RunTask(task)
}
```

## V8执行流程-JIT（Just In Time）

![[v8-js-run.png]]![[V8-jit-run2.png]]
### V8引擎的重要部件
- Parser （解析器）
	- 负责将JS源码转化为AST
- Ignition （基线编译器）
	-  interpreter ，解释器，负责将AST转换成ByteCode，解释执行ByteCode；
	- 收集Turbofan优化编译器所需的信息
- TurboFan （优化编译器）
	- compiler，编译器。利用Ignition收集的信息，将ByteCode编译成二进制机器吗
- Orinoco （垃圾回收器）
	- 垃圾回收
- Liftoff（webAssemly 基线编译器）

### v8工作流程：

1. 初始化基础环境
2. 根据高级语言生成AST和作用域
3. 根据AST和作用域生成字节码（ByteCode）
4. 解释执行字节码（ByteCode）
5. 对热点代码（项目中反复使用的代码）进行监控
6. 编译热点代码为二进制的机器码
7. 热点代码改变，进行反优化操作

代码执行过程：

- 源代码经过编译器生成AST后，V8就可以生成该段代码的执行上下文 （变量对象、作用域链、this）
- 有了AST和执行上下文，解释器根据AST生成字节码，然后解释执行字节码。
- 在V8里，存在监控解释器执行状态的模块。在解释器执行字节码的过程中，如果解释器在执行字节码的过程中，如果监控到某部分代码多次重复执行，那么监控模块回给这部分代码打上**热点标记**。
- 当代码打上了**热点标记**后，V8会将着部分代码交给优化编辑器（TurboFan），优化编译器会在后台将这部分字节码编译为二进制代码，
- 当再次执行到热点代码时，V8选择执行编译后的二进制代码，这样大大提高执行效率。

> 当V8执行越久，被编译成机器吗的热点代码久越多，执行的效率就越高，但同时占用的内存就越多。V8针对这个问题 会有一个弹性的空间，做内存与性能之间的平衡。


## 垃圾回收
[[内存回收机制]]

## 代码缓存 Code Caching
chrome中存在很多功能，影响JS的执行过程。  
用户访问相同的页面，且页面关联的脚本没有任何改动。代码缓存会让JS的加载和执行变得更快。
![[V8-Code-Caching.png]]
代码缓存被分为 cold、warm、hot 三个等级。
1.  用户首次请求 JS 文件时（即 cold run），Chrome 将下载该文件并将其提供给 V8 进行编译，并将该文件缓存到磁盘中。
2.  当用户第二次请求这个 JS 文件时（即 warm run），Chrome 将从浏览器缓存中获取该文件，并将其再次交给 V8 进行编译。在 warm run 阶段编译完成后，编译的代码会被反序列化，作为元数据附加到缓存的脚本文件中。 
3.  当用户第三次请求这个 JS 文件时（即 hot run），Chrome 从缓存中获取文件和元数据，并将两者交给 V8。V8 将跳过编译阶段，直接反序列化元数据。