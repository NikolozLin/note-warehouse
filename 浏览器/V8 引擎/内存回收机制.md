---
date created: 2022-04-11 10:49
date updated: 2023-02-23 12:26
---

## 概况

V8逐行执行JS代码时，遇到函数会创建_执行上下文_并添加到堆栈的栈顶，_执行上下文_ 中的变量对象`variable Object` 中包含了函数中声明的所以变量，当执行完毕后_执行上下文_从栈顶弹出。那么其中包含的变量会统一被回收，如果不进行回收会导致程序的性能下降甚至内存溢出。

在node环境下，**process.memoryUsage()** 命令可查看内存分配

```
//process.memoryUsage()
{
	rss:number,
	heapTotal:number,
	heapUsed:number,
	external:number,
}
```

- rss（resident set size）：所有内存占用，包括指令区和堆栈
- heapTotal：V8引擎可以分配的最大堆内存，包含下面的 heapUsed
- heapUsed：V8引擎已经分配使用的堆内存
- external：V8管理C++对象绑定到JavaScript对象上的内存

### V8引擎内存限制

V8引擎会自动进行内存回收，但是V8引擎中使用的内存不是无限制的。默认情况下64位的系统能使用内存约1.4GB ,  32位系统能使用内存越为0.7GB。
**限制内存大小的原因：**

1. _JS单线程机制_ ：因为浏览器的脚本语言，主要用在操作DOM、与用户互交。那就决定了他是单线程。 那么意味着在V8引擎执行垃圾回收时，程序的其他逻辑都需要进行等待，直到垃圾回收完成。
2. _垃圾回收机制_ ：垃圾回收操作是非常耗时的操作，当内存越大那么回收一次所需要的时间就越大。同时JS是单线程，此时浏览器会处于等待状态，会失去对用户的响应。如果此时有动画在播放，动画也会掉帧。

### 突破V8引擎内存限制

一、在浏览器一般不会出现处理操作几个GB内存的场景，但在Node环境涉及`I/O`操作比浏览器多，可能存在内存溢出问题。 不过V8提供配置项可以调教内存大小，但是需要在Node初始化前进行配置。

```
// 该命令可以用来查看node中可用的V8引擎的选项及其含义 
node --v8-options

// 设置新生代内存中单个半空间的内存最小值，单位MB
node --min-semi-space-size=1024 xxx.js 
  
// 设置新生代内存中单个半空间的内存最大值，单位MB 
node --max-semi-space-size=1024 xxx.js 
  
// 设置老生代内存最大值，单位MB 
node --max-old-space-size=2048 xxx.js
```

二、 使用 Buffer
(详细介绍看➡️)[[Buffer]].
buffer 对应V8堆内存外的一块原始内存，时JS与C++结合的模块。

## V8内存结构

![[V8-memory-structure.png]]
V8引擎的内存结构分成下面几部分：

- `新生代(new_space)` :
  - 大部分对戏那个一开始分配在这里
  - 这个区域相对较小，且给分为两部分：
    1. Nursery部分，用来分配内存，新生的对象都分配在这个区域
    2. Intermediate部分，如果Nursery部分在第一次GC后才存活（存活对象复制到这部分中），标识位会改变，会进入逻辑上的Intermediate的子生代。
- `老生代(old_space)` :
  - 在新生代存活一段时间后依旧存活对象会移动到老生代，老生代GC频率比新生代低。
  - 老生代分为： `老生代指针区`、 `老生代数据区`
- `大对象区(large_object_space)` :
  - 存放体积超越其他区大小的对象，主要避免大对象的拷贝，使用该空间专门存储大对象
- `代码区(code_space)` :
  - 主要存放代码对象过，最大限制为512MB，也是唯一拥有执行权的内存。
- `单元区、属性单元区、Map区(Cell space、property cell space、Map space)` :
  - Map空间存放对象的Map信息也就是[隐藏类(Hiden Class)]最大限制为8MB；
  - 每个Map对象固定大小，为了快速定位，所以将该空间单独出来。

## 垃圾回收机制

基本流程：

1. 确认存活/死亡对象
2. 回收/再利用死亡对象所占内存
3. 压缩/整理内存（可选）

### 回收策略

V8的垃圾回收策略是`分代式垃圾回收机制`，根据_对象存活时间_将内存进行_分代_ ，不同的_分代_采用不同的垃圾回收算法。这样的垃圾回收更加有针对性、更高效。

| 名称  | 算法                   | 大小                       |
| --- | -------------------- | ------------------------ |
| 新生代 | Parallel Scavenge 算法 | 32MB（64位）/ 16MB（32位）     |
| 老生代 | 标记清除、标记整理算法          | 1400MB（64位）/ 700MB（32 位） |

### 新生代

新生代使用`Scavenge`算法，将空间以分为二，前面内存结构中的Nursery在算法中称为`From`空间，Intermediate 称为`To`空间。  两个空间始终有一个处于使用状态，一个处于闲置状态。

- 声明新对象首先会分配到`From`空间。
- 当GC时 `From`还有存活对象会_按顺序_复制到`To`空间，非存活对象全部清除。
- 复制完成后，`From`空间和`To`空间进行角色转换。

### 对象晋升

`晋升(promotion)` : 内存中一个对像多次复制还存活，那么会认为是一个生命周期较长的对象。下次GC时候会直接移动到老生代中.
晋升条件：

- 对象是否经历过一次`Scavenge`算法
- `To`空间的内存占比是否超过_25%_
  > （如果`To`空间使用占比过高，会影响新创建的对象，所以超过25%部分的对象直接转移到老生代里进行管理）

晋升历程：
GC 是 判断对象是否经历一次`Scavenge`算法

- 是，转移到老生代
- 否，移动到`To`空间，如果此时`To`空间内存使用占比已超过_25%_，则该对象移动到老生代。

### 老生代

老生代存着大量存活对象，就不适合用`Scvenge`算法，该用`标记清楚（Mark-Sweep）` 、`标记整理（Mark- Compact）`进行管理。

#### 标记清除（Mark-Sweep）

早期使用“引用计数”的算法进行内存回收，但是遇到循环引用时就没办法正确回收对象。造成内存泄漏。  为了避免泄漏而改用`Mark Sweep`算法。

`Mark Sweep`步骤：

1. 垃圾回收器在内部创建`根列表`，用于根节点出发去访问哪些能访问的节点。（JS中window对象可以视为一个根节点）
   > 全局对象、本地函数的局部变量和参数、当前潜逃链上的其他函数的变量和参数
2. 垃圾回收器从所有的根节点出发，遍历所有能访问的节点，并将其定义为_活动_的，不能访问到地方为_非活动_，将被视为垃圾。
3. 垃圾回收器释放所有非活动内存块。

#### 标记整理（Mark- Compact）

进过`Mark Sweep`后，内存会存在碎块需要进行整理，避免发生存在内存容量足够但是无法进行分配的问题。

`Mark Compact`步骤：

1. 回收过程中，死亡对象清楚后，会将活动对象往堆内存一端移动，移动完成后清理边界外全部内存。

---

将`Mark Sweep`、`Mark Compact`步骤后结合起来就是一次旧生代垃圾回收过程。

## 垃圾回收执行与优化

V8 执行特点：

1. 垃圾回收在主线程上执行
2. 一次执行完整的垃圾回收流程

JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿（Stop-The-World）**

**优化：**
由于全停顿容易造成主线程卡顿，因此采用许多优化方案

1. 并行回收 ：执行完整的垃圾回收过程重，使用多个辅助线程并行执行垃圾回收。
2. 增量式垃圾回收 ： 垃圾回收标记工作分成小块，在主线程执不同任务执行_间隙_之间执行。
3. 并发回收 ： 允许主线程执行JS的过程，辅助线程能够在后台完成执行垃圾回收操作。只有个别垃圾回收器做一些特殊的操作需要占用主线程。

## 避免内存溢出

- 尽可能少的创建全局变量，非要使用，用完设置为null
- 手动清楚定时器
- 减少闭包使用
  闭包是JS中的一个高级特性，巧妙地利用闭包可以帮助我们实现很多高级功能。一般来说，我们在查找变量时，在本地作用域中查找不到就会沿着作用域链从内向外单向查找，但是闭包的特性可以让我们在外部作用域访问内部作用域中的变量，示例如下：
  ```js
    function foo() { 
    	let local = 123;
    	return function() { return local; }
    }
    
    const bar = foo(); 
    console.log(bar()); // -> 123
  ```
  在这个示例中，`foo`函数执行完毕后会返回一个匿名函数，该函数内部引用了`foo`函数中的局部变量`local`，并且通过变量`bar`来引用这个匿名的函数定义，通过这种闭包的方式我们就可以在`foo`函数的外部作用域中访问到它的局部变量`local`。
  一般情况下，当`foo`函数执行完毕后，它的作用域会被销毁，但是由于存在变量引用，作用域链上存活在内存中 ，只有当我们取消掉对匿名函数的引用才会进入垃圾回收阶段。
- 清除对DOM引用
- 使用弱引用 （WeakMap、WeakSet）
