---
date created: 2022-03-29 16:51
date updated: 2022-04-06 16:38
---

# 浏览器输入URL到页面显示发生了什么

1. URL解析（编码）
2. 检查资源缓存
3. DNS解析
4. 建立TCP连接
5. TLS协商密钥
6. 发送请求&接收响应
7. 关闭TCP连接

## URL 编码

- URI（统一资源标志符），URL（统一资源定位符）是一种具体的URI，是URI的一个子集合。在某个规则下能唯一标识资源的就是URI，在其基础上给出资源访问方式的就是URL。
- 网络标准RFC1738规定，URL只能使用普通字符[0-9a-zA-Z]、特殊字符`$-_.+!*'(),`一些保留字才可以不需要编码直接用于URL。
- 如果URL需要编码油浏览器决定，但是如果在已经打开的页面发送GET或者POST请求，页面的HTML文件有一个`<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">`其中chartset就规定发URL的编码方式。
- 为了解决编码混乱的问题，于是使用JavaScript对URL进行编码后再传输，常用`encodeURI` `encodeURIComponent`，最后输出utf-8编码。
- `encodeURI` `encodeURIComponent`区别
  - `encodeURI()` 不会对下列字符编码： ASCII编码、数字、`- _ . ! ~ * ' ( ) ; , / ? : @ & = + $ #` 进行编码
  - `encodeURIComponent()` 不会对下列字符编码： ASCII编码、数字、`- _ . ! ~ * ' ( )` 进行编码,其他一律转码
  - 两种方法的转义范围不同，当对`整个URL`进行转义时使用`encodeURI()`，单转义后的结果不用请求。如果需要对`URL参数部分`进行编译则使用`encodeURIComponent()`

UTF-8就是为了解决向后兼容ASCII码而设计,这使得原来处理ASCII字符的软件无须或只须做少部分修改，即可继续使用. 最后utf-8成了通用的编码。

> 补充：具体如何转码可以参考 [[Web中的数据类型]]

## 缓存检查

浏览器会在发送请求前检查有没有缓存可以用。
![[http-cache.png]]

### 强缓存

检查步骤

1. 检查是否存在强缓存（Expires、Cache-Control），不存在，直接访问服务器。
2. 存在缓存结构和标识，但是结果以失效，强缓存失效，使用协商缓存。
3. 存在缓存结构和标识，但是结果生效，强缓存生效，直接返回缓存结果。

强缓存相关字段：Expire 、Cache-Control

> `Cache-Control/Expires`同时存在时，只有`Cache-Control`生效

**Expires**
HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求的结果缓存的到期时间。如果下次发送同样请求，客户端的时间小于`Expires`的值时，直接使用缓存结果。

> expire存在问题，当客户端与服务端 时间不一致那么`Expire`并不能很好工作。1.1协议使用Cache-Control进行代替。

**Cache-Control**
HTTP/1.1中控制页面缓存的字段，缓存相关的值有：

- `public` ：响应可以被任何对象（客户端、代理服务器、CDN等）缓存。
- `private`：响应只能被耽搁用户（客户端）缓存，不能作为共享缓存。
- `no-cache` ：客户端进行缓存，但是请求发送到客户端（协商缓存）来判断是否使用
- `no-store` ： 所有内容不使用缓存，强缓存、协商缓存都不使用
- `max-age=<seconds>` :  缓存最大存储时间，超过这个时间缓存认为过期。

### 协商缓存

当缓存失效后，浏览器携带缓存标识向服务器发送请求，服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

1. 协商缓存**生**效，返回304，服务器告诉浏览器资源未更新，浏览器再去缓存中访问资源.
2. 协商缓存**失**效，返回200和请求结果.

协商缓存相关字段：`Last-Modified/If-Modified-Since`   、`Etag/If-None-Match`

> `Etag/If-None-Match`优先级高。

**Last-Modified/If-Modified-Since**

- Last-Modified ：服务器响应请求，返回所请求文件在服务器最后修改时间。
- If-Modefied-Since ：
  - 上次请求后，再次请求相同资源，if-modefied-since字段填写上次last-modefied的值。
  - 服务器接受后会根据if-modefined-since的值 与服务器文件最后修改时间对比。
  - 如果最后修改时间**大于**if-modefined-since的值 返回资源，状态码 200。 否则返回状态码304.

**Etag/If-None-Match**

- Etag ：服务器响应请求时，返回当前资源文件的唯一标识（由服务器生成）。
- If-None-Match ：
  - 再次请求相同文件，请求的If-None_Match字段填写上次请求的Etag的值
  - 服务器判断If-None-Match字段与服务器文件Eatg是否相同，如果不同返回资源，状态码200 。 否则返回状态码304，资源无需跟新

> Etag主要为了解决Last-Modified无法解决的一些问题:
>
> - 一些文件也许周期性的更改,但是它的内容并不改变(仅仅改变的是修改时间),这个时候我们不希望客户端认为这个文件被修改了,而重新获取资源.
> - 某些文件修改非常频繁,比如在秒一下的时间内进行修改(比如1s内修改了N次),If-Modified-Since能检查到的粒度是秒级的,这种修改是无法判断的(或者说UNIX记录MTIME只能精确到秒)
> - 某些服务器不能精确的得到文件的最后修改时间;

### 缓存位置
-   Service Worker：浏览器独立线程进行缓存
-   Memory Cache：内存缓存
-   Disk Cache：硬盘缓存
-   Push Cache：推送缓存（HTTP/2中的）
## DNS解析

DNS可以将主机域名转换为IP地址
转换整体流程 （[www.google.com](http://www.google.com) 为例）

1. 输入URL后，浏览器检测缓存中是否存在域名对应的解析过的`IP地址`，有直接使用缓存的内容。
2. 如果不存在与浏览器缓存，则检查本地的hosts文件是否有该网址的映射，有直接使用。
3. hosts文件中不存在相关映射，则查询本地DNS解析器缓存（路由器缓存），有直接使用。
4. 如果hosts文件和本地DNS解析器没有映射关系，会根据`TCP/IP`设置的的首选DNS服务器（本地DNS服务器）进行查询，有查询域名的资源,则返回结果（具有权威性）
5. 查询的地址不由本地DNS服务器区域解析，但缓存中存在相关映射，则返回相关结果(不具有权威性)
6. 本地DNS服务器和服务器的缓存都解析失败，根据本地DNS服务器的设置（时候设置转发器）进行查询
   - 未设置转发(迭代模式)
     1. 本地DNS服务器直接将解析请求发送到 13个`根域名服务器`，根域名服务器收到请求后判断`域名`后谁进行授权管理，然后返回一个负责该顶级域名（.com）服务器的`IP`地址。
     2. 本地DNS服务器收到IP信息后，发送解析请求到该IP的服务器。顶级域名（.com）服务器如果无法解析，则会找到管理（google.com）的二级域名DNS服务器的IP ，返回给本地DNS服务器
     3.重复上面行为 直到找到`www.google.com`
   - 有转发设置（递归模式）
     1. 本地DNS服务器将请求转发到下一级的DNS服务器()，让下一级解析。如果下一级无法解析，则下一级转给下级的服务器。
        > 已递归模式进行解析，如果本地DNS无法解析，转发给根域名服务器让根域名服务器去解析，根没有的话根服务器取找下一级（以此类推）。本地DNS服务器值只发送一次请求。
     2. 直到查询到结果或者报错。
7. 最后 将解析结果返回给浏览器

### 迭代查询和递归查询

递归： 客户端发送一次请求，要求得到最后的结果
迭代： 客户端发送一次请求，如果它没有授权回答就返回一个能解析的域名服务器，客户端需要重新发出解析请求。重复步骤，直到最终结果

## HTTP请求
- 连接：三次握手
	> 为什么需要三次握手
	>  - 明确客户端服务器两者都是正常的，并且初始化两者的序列号（ISN inital Sequence Number）
	>  - 防止已经失效的请求报文段又突然发送到服务器（网络拥塞）
- 断开： 四次挥手
	> 为什么要四次挥手
	> 由于 TCP 的**半关闭**（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
	> 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入**半关闭状态**。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就**完全关闭**了TCP连接。
### HTTPS（SSL/TLS）
通过非对程+对称加密机制，对网络传输内容进行加密传输。
> 涉及概念 非对称加密、对称加密、数字证书、数字签名

建立连接过程
1.  某网站拥有用于非对称加密的公钥A、私钥A’。
2.  浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3.  浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4.  服务器拿到后用私钥A’解密得到密钥X。
5.  这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。
6. 建立连接后服务器维护一个sessionID ，后续传输内容根据sessionID对应的密钥X进行加解密。（大大减少每次建立连接的资源消耗）

>但是这样的连接存在中间人攻击的风险，因为浏览器不知道收到的公钥来自站点 还是来自中间人
**数字证书**
数字证书解决上面中间人攻击的问题，站点使用HTTPS前，向CA机构申领数字证书，其中包含证书持有者信息、共钥信息等。浏览器获取站点公钥直接在证书取就可以了。
**数字签名**
用于数字证书的防篡改。
数字证书制作过程：
1. CA机构本身拥有非对称加密的公钥、密钥
2. CA机构对证书明文 T 进行hash
3. 对hash结果进行私钥加密，得到数字签名 S
4. 最后明文 T 和数字签名 S 共同组成**数字证书**

证书验证过程：
1. 获得证书，得到明文T 和 签名S
2. 用CA机构的公钥对 S 解密 得到 S’
3. 用证书指明的 hash算法 对明文进行加hash 得到T'
4. 如果S' 等于T' 那么该证书可信


